<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name.viewport content="width=device-width, initial-scale=1.0">
    <title>Study Guide - Algoritmos e Estruturas de Dados</title>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
        }

        pre {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 5px;
        }

        h1,
        h2,
        h3 {
            color: #333;
        }
                .button-container {
            margin-top: 20px;
        }

        .button {
            display: inline-block;
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            background-color: #007bff;
            text-align: center;
            text-decoration: none;
            border-radius: 5px;
        }

        .button:hover {
            background-color: #0056b3;
        }
    </style>
</head>

<body>
    <h1>Algoritmos e Estruturas de Dados</h1>
<div class="button-container">
    <a href="index.html" class="button">Voltar para Resumo PHP</a>
</div>
    <h2>1. Introdução a Grafos e Árvores</h2>
    <h3>Grafos</h3>
    <p>Grafos são modelos matemáticos que representam relações entre objetos. Eles consistem em vértices (ou nós)
        conectados por arestas.</p>
    <pre><code class="language-c">
// Representação de um grafo usando matriz de adjacência
#define V 5
int graph[V][V] = {
    {0, 1, 0, 0, 1},
    {1, 0, 1, 0, 0},
    {0, 1, 0, 1, 0},
    {0, 0, 1, 0, 1},
    {1, 0, 0, 1, 0}
};
    </code></pre>

    <h3>Árvores</h3>
    <p>Árvores são grafos acíclicos conectados. Elas possuem um nó raiz e nós filhos que formam uma hierarquia.</p>
    <pre><code class="language-c">
// Estrutura de um nó da árvore
typedef struct No {
    int valor;
    struct No* esq;
    struct No* dir;
} No;
    </code></pre>

    <h2>2. Introdução à Análise de Complexidade de Algoritmos</h2>
    <h3>Análise de Complexidade</h3>
    <p>A análise de complexidade avalia o desempenho de algoritmos em termos de tempo de execução e uso de memória. As
        notações mais comuns são O, Ω e Θ.</p>
    <pre><code class="language-c">
// Exemplo de complexidade O(n)
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}
    </code></pre>

    <h2>3. Estruturas Linearmente Encadeadas</h2>
    <h3>Listas Encadeadas</h3>
    <p>Listas encadeadas são coleções de nós onde cada nó aponta para o próximo nó da lista.</p>
    <pre><code class="language-c">
// Estrutura de um nó da lista encadeada
typedef struct Nodo {
    int valor;
    struct Nodo* prox;
} Nodo;

// Função para inserir no início da lista
void insereInicio(Nodo** head, int valor) {
    Nodo* novoNodo = (Nodo*)malloc(sizeof(Nodo));
    novoNodo->valor = valor;
    novoNodo->prox = *head;
    *head = novoNodo;
}
    </code></pre>

    <h3>Pilhas</h3>
    <p>Pilhas são estruturas LIFO (Last In, First Out) onde o último elemento inserido é o primeiro a ser removido.</p>
    <pre><code class="language-c">
// Estrutura de uma pilha
typedef struct Pilha {
    int topo;
    int capacidade;
    int* array;
} Pilha;

// Função para criar uma pilha
Pilha* criaPilha(int capacidade) {
    Pilha* pilha = (Pilha*)malloc(sizeof(Pilha));
    pilha->capacidade = capacidade;
    pilha->topo = -1;
    pilha->array = (int*)malloc(pilha->capacidade * sizeof(int));
    return pilha;
}

// Função para empilhar um elemento
void empilha(Pilha* pilha, int item) {
    pilha->array[++pilha->topo] = item;
}
    </code></pre>

    <h3>Filas</h3>
    <p>Filas são estruturas FIFO (First In, First Out) onde o primeiro elemento inserido é o primeiro a ser removido.
    </p>
    <pre><code class="language-c">
// Estrutura de uma fila
typedef struct Fila {
    int capacidade;
    int frente, tras, tamanho;
    int* array;
} Fila;

// Função para criar uma fila
Fila* criaFila(int capacidade) {
    Fila* fila = (Fila*)malloc(sizeof(Fila));
    fila->capacidade = capacidade;
    fila->frente = fila->tamanho = 0;
    fila->tras = capacidade - 1;
    fila->array = (int*)malloc(fila->capacidade * sizeof(int));
    return fila;
}

// Função para enfileirar um elemento
void enfileira(Fila* fila, int item) {
    fila->tras = (fila->tras + 1) % fila->capacidade;
    fila->array[fila->tras] = item;
    fila->tamanho = fila->tamanho + 1;
}
    </code></pre>

    <h2>4. Árvores Binárias de Busca</h2>
    <h3>Definição e Propriedades</h3>
    <p>Árvores binárias de busca são árvores binárias onde cada nó tem no máximo dois filhos e o valor do nó da esquerda
        é menor que o valor do nó pai, que por sua vez é menor que o valor do nó da direita.</p>
    <pre><code class="language-c">
// Estrutura de um nó da árvore binária de busca
typedef struct NoArv {
    int valor;
    struct NoArv* esq;
    struct NoArv* dir;
} NoArv;

// Função para criar um novo nó
NoArv* novoNo(int valor) {
    NoArv* temp = (NoArv*)malloc(sizeof(NoArv));
    temp->valor = valor;
    temp->esq = temp->dir = NULL;
    return temp;
}

// Função para inserir um novo nó
NoArv* insere(NoArv* no, int valor) {
    if (no == NULL) return novoNo(valor);
    if (valor < no->valor)
        no->esq = insere(no->esq, valor);
    else if (valor > no->valor)
        no->dir = insere(no->dir, valor);
    return no;
}
    </code></pre>

    <h2>5. Árvores AVL</h2>
    <h3>Definição e Propriedades</h3>
    <p>Árvores AVL são árvores binárias de busca autobalanceadas onde a altura das subárvores esquerda e direita de
        qualquer nó difere no máximo por um.</p>
    <pre><code class="language-c">
// Estrutura de um nó da árvore AVL
typedef struct NoAVL {
    int valor;
    struct NoAVL* esq;
    struct NoAVL* dir;
    int altura;
} NoAVL;

// Função para obter a altura de um nó
int altura(NoAVL* N) {
    if (N == NULL)
        return 0;
    return N->altura;
}

// Função para realizar uma rotação à direita
NoAVL* rotacaoDireita(NoAVL* y) {
    NoAVL* x = y->esq;
    NoAVL* T2 = x->dir;

    // Executa rotação
    x->dir = y;
    y->esq = T2;

    // Atualiza alturas
    y->altura = max(altura(y->esq), altura(y->dir)) + 1;
    x->altura = max(altura(x->esq), altura(x->dir)) + 1;

    // Retorna nova raiz
    return x;
}
    </code></pre>

    <h2>6. Listas Encadeadas - Exercícios</h2>
    <h3>Exercícios de Implementação</h3>
    <p>Implementação de funções para operações em listas encadeadas: menor, maior, média, número de elementos,
        concatenação, inversão, sublista.</p>
    <pre><code class="language-c">
// Função para encontrar o menor elemento
int menorElemento(Nodo* head) {
    int min = head->valor;
    Nodo* temp = head;
    while (temp != NULL) {
        if (temp->valor < min)
            min = temp->valor;
        temp = temp->prox;
    }
    return min;
}

// Função para encontrar o maior elemento
int maiorElemento(Nodo* head) {
    int max = head->valor;
    Nodo* temp = head;
    while (temp != NULL) {
        if (temp->valor > max)
            max = temp->valor;
        temp = temp->prox;
    }
    return max;
}
    </code></pre>

</body>

</html>